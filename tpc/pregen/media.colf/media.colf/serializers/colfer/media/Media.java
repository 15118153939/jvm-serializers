package serializers.colfer.media;


// This file was generated by colf(1); DO NOT EDIT


import static java.lang.String.format;
import java.nio.BufferOverflowException;
import java.nio.BufferUnderflowException;
import javax.xml.bind.TypeConstraintException;
import javax.xml.bind.DataBindingException;


/**
 * Data bean with built-in serialization support.
 * @author generated by colf(1)
 * @see <a href="https://github.com/pascaldekloe/colfer">Colfer's home</a>
 */
public class Media implements java.io.Serializable {

	/** The upper limit for serial byte sizes. */
	public static int colferSizeMax = 16 * 1024 * 1024;

	/** The upper limit for the number of elements in a list. */
	public static int colferListMax = 64 * 1024;

	private static final java.nio.charset.Charset _utf8 = java.nio.charset.Charset.forName("UTF-8");

	public String uri = "";
	public String title = "";
	public int width;
	public int height;
	public String format = "";
	public long duration;
	public long size;
	public String persons = "";
	public String copyright = "";
	public int bitrate;
	public boolean hasBitrate;
	public boolean flashPlay;
	public boolean javaPlay;


	/**
	 * Serializes the object.
	 * @param buf the data destination.
	 * @param offset the first byte index.
	 * @return the index of the first byte after the last byte written.
	 * @throws BufferOverflowException when {@code buf} is too small.
	 * @throws IllegalStateException on an upper limit breach defined by either {@link #colferSizeMax} or {@link #colferListMax}.
	 */
	public int marshal(byte[] buf, int offset) {
		int i = offset;
		try {

			if (! this.uri.isEmpty()) {
				buf[i++] = (byte) 0;
				String s = this.uri;
				int sLength = s.length();

				int start = ++i;
				for (int sIndex = 0; sIndex < sLength; sIndex++) {
					char c = s.charAt(sIndex);
					if (c < 128) {
						buf[i++] = (byte) c;
					} else if (c < 2048) {
						buf[i++] = (byte) (192 | c >>> 6);
						buf[i++] = (byte) (128 | c & 63);
					} else if (! Character.isSurrogate(c)) {
						buf[i++] = (byte) (224 | c >>> 12);
						buf[i++] = (byte) (128 | c >>> 6 & 63);
						buf[i++] = (byte) (128 | c & 63);
					} else if (++sIndex != sLength) {
						int cp = Character.toCodePoint(c, s.charAt(sIndex));
						buf[i++] = (byte) (240 | cp >>> 18);
						buf[i++] = (byte) (128 | cp >>> 12 & 63);
						buf[i++] = (byte) (128 | cp >>> 6 & 63);
						buf[i++] = (byte) (128 | cp & 63);
					}
				}

				int size = i - start;
				if (size > colferSizeMax)
					throw new IllegalStateException(format("colfer: field serializers/colfer/media.media.uri size %d exceeds %d UTF-8 bytes", size, colferSizeMax));

				int shift = 0;
				for (int x = size; (x & ~((1 << 7) - 1)) != 0; x >>>= 7) shift++;
				if (shift != 0) System.arraycopy(buf, start, buf, start + shift, size);
				i = start + shift + size;

				start--;
				while ((size & ~((1 << 7) - 1)) != 0) {
					buf[start++] = (byte) (size | 0x80);
					size >>>= 7;
				}
				buf[start++] = (byte) size;
			}

			if (! this.title.isEmpty()) {
				buf[i++] = (byte) 1;
				String s = this.title;
				int sLength = s.length();

				int start = ++i;
				for (int sIndex = 0; sIndex < sLength; sIndex++) {
					char c = s.charAt(sIndex);
					if (c < 128) {
						buf[i++] = (byte) c;
					} else if (c < 2048) {
						buf[i++] = (byte) (192 | c >>> 6);
						buf[i++] = (byte) (128 | c & 63);
					} else if (! Character.isSurrogate(c)) {
						buf[i++] = (byte) (224 | c >>> 12);
						buf[i++] = (byte) (128 | c >>> 6 & 63);
						buf[i++] = (byte) (128 | c & 63);
					} else if (++sIndex != sLength) {
						int cp = Character.toCodePoint(c, s.charAt(sIndex));
						buf[i++] = (byte) (240 | cp >>> 18);
						buf[i++] = (byte) (128 | cp >>> 12 & 63);
						buf[i++] = (byte) (128 | cp >>> 6 & 63);
						buf[i++] = (byte) (128 | cp & 63);
					}
				}

				int size = i - start;
				if (size > colferSizeMax)
					throw new IllegalStateException(format("colfer: field serializers/colfer/media.media.title size %d exceeds %d UTF-8 bytes", size, colferSizeMax));

				int shift = 0;
				for (int x = size; (x & ~((1 << 7) - 1)) != 0; x >>>= 7) shift++;
				if (shift != 0) System.arraycopy(buf, start, buf, start + shift, size);
				i = start + shift + size;

				start--;
				while ((size & ~((1 << 7) - 1)) != 0) {
					buf[start++] = (byte) (size | 0x80);
					size >>>= 7;
				}
				buf[start++] = (byte) size;
			}

			if (this.width != 0) {
				int x = this.width;
				if (x < 0) {
					x = -x;
					buf[i++] = (byte) (2 | 0x80);
				} else
					buf[i++] = (byte) 2;
				while ((x & ~((1 << 7) - 1)) != 0) {
					buf[i++] = (byte) (x | 0x80);
					x >>>= 7;
				}
				buf[i++] = (byte) x;
			}

			if (this.height != 0) {
				int x = this.height;
				if (x < 0) {
					x = -x;
					buf[i++] = (byte) (3 | 0x80);
				} else
					buf[i++] = (byte) 3;
				while ((x & ~((1 << 7) - 1)) != 0) {
					buf[i++] = (byte) (x | 0x80);
					x >>>= 7;
				}
				buf[i++] = (byte) x;
			}

			if (! this.format.isEmpty()) {
				buf[i++] = (byte) 4;
				String s = this.format;
				int sLength = s.length();

				int start = ++i;
				for (int sIndex = 0; sIndex < sLength; sIndex++) {
					char c = s.charAt(sIndex);
					if (c < 128) {
						buf[i++] = (byte) c;
					} else if (c < 2048) {
						buf[i++] = (byte) (192 | c >>> 6);
						buf[i++] = (byte) (128 | c & 63);
					} else if (! Character.isSurrogate(c)) {
						buf[i++] = (byte) (224 | c >>> 12);
						buf[i++] = (byte) (128 | c >>> 6 & 63);
						buf[i++] = (byte) (128 | c & 63);
					} else if (++sIndex != sLength) {
						int cp = Character.toCodePoint(c, s.charAt(sIndex));
						buf[i++] = (byte) (240 | cp >>> 18);
						buf[i++] = (byte) (128 | cp >>> 12 & 63);
						buf[i++] = (byte) (128 | cp >>> 6 & 63);
						buf[i++] = (byte) (128 | cp & 63);
					}
				}

				int size = i - start;
				if (size > colferSizeMax)
					throw new IllegalStateException(format("colfer: field serializers/colfer/media.media.format size %d exceeds %d UTF-8 bytes", size, colferSizeMax));

				int shift = 0;
				for (int x = size; (x & ~((1 << 7) - 1)) != 0; x >>>= 7) shift++;
				if (shift != 0) System.arraycopy(buf, start, buf, start + shift, size);
				i = start + shift + size;

				start--;
				while ((size & ~((1 << 7) - 1)) != 0) {
					buf[start++] = (byte) (size | 0x80);
					size >>>= 7;
				}
				buf[start++] = (byte) size;
			}

			if (this.duration != 0) {
				long x = this.duration;
				if (x < 0) {
					x = -x;
					buf[i++] = (byte) (5 | 0x80);
				} else
					buf[i++] = (byte) 5;
				for (int n = 0; n < 8 && (x & ~((1L << 7) - 1)) != 0; n++) {
					buf[i++] = (byte) (x | 0x80);
					x >>>= 7;
				}
				buf[i++] = (byte) x;
			}

			if (this.size != 0) {
				long x = this.size;
				if (x < 0) {
					x = -x;
					buf[i++] = (byte) (6 | 0x80);
				} else
					buf[i++] = (byte) 6;
				for (int n = 0; n < 8 && (x & ~((1L << 7) - 1)) != 0; n++) {
					buf[i++] = (byte) (x | 0x80);
					x >>>= 7;
				}
				buf[i++] = (byte) x;
			}

			if (! this.persons.isEmpty()) {
				buf[i++] = (byte) 7;
				String s = this.persons;
				int sLength = s.length();

				int start = ++i;
				for (int sIndex = 0; sIndex < sLength; sIndex++) {
					char c = s.charAt(sIndex);
					if (c < 128) {
						buf[i++] = (byte) c;
					} else if (c < 2048) {
						buf[i++] = (byte) (192 | c >>> 6);
						buf[i++] = (byte) (128 | c & 63);
					} else if (! Character.isSurrogate(c)) {
						buf[i++] = (byte) (224 | c >>> 12);
						buf[i++] = (byte) (128 | c >>> 6 & 63);
						buf[i++] = (byte) (128 | c & 63);
					} else if (++sIndex != sLength) {
						int cp = Character.toCodePoint(c, s.charAt(sIndex));
						buf[i++] = (byte) (240 | cp >>> 18);
						buf[i++] = (byte) (128 | cp >>> 12 & 63);
						buf[i++] = (byte) (128 | cp >>> 6 & 63);
						buf[i++] = (byte) (128 | cp & 63);
					}
				}

				int size = i - start;
				if (size > colferSizeMax)
					throw new IllegalStateException(format("colfer: field serializers/colfer/media.media.persons size %d exceeds %d UTF-8 bytes", size, colferSizeMax));

				int shift = 0;
				for (int x = size; (x & ~((1 << 7) - 1)) != 0; x >>>= 7) shift++;
				if (shift != 0) System.arraycopy(buf, start, buf, start + shift, size);
				i = start + shift + size;

				start--;
				while ((size & ~((1 << 7) - 1)) != 0) {
					buf[start++] = (byte) (size | 0x80);
					size >>>= 7;
				}
				buf[start++] = (byte) size;
			}

			if (! this.copyright.isEmpty()) {
				buf[i++] = (byte) 8;
				String s = this.copyright;
				int sLength = s.length();

				int start = ++i;
				for (int sIndex = 0; sIndex < sLength; sIndex++) {
					char c = s.charAt(sIndex);
					if (c < 128) {
						buf[i++] = (byte) c;
					} else if (c < 2048) {
						buf[i++] = (byte) (192 | c >>> 6);
						buf[i++] = (byte) (128 | c & 63);
					} else if (! Character.isSurrogate(c)) {
						buf[i++] = (byte) (224 | c >>> 12);
						buf[i++] = (byte) (128 | c >>> 6 & 63);
						buf[i++] = (byte) (128 | c & 63);
					} else if (++sIndex != sLength) {
						int cp = Character.toCodePoint(c, s.charAt(sIndex));
						buf[i++] = (byte) (240 | cp >>> 18);
						buf[i++] = (byte) (128 | cp >>> 12 & 63);
						buf[i++] = (byte) (128 | cp >>> 6 & 63);
						buf[i++] = (byte) (128 | cp & 63);
					}
				}

				int size = i - start;
				if (size > colferSizeMax)
					throw new IllegalStateException(format("colfer: field serializers/colfer/media.media.copyright size %d exceeds %d UTF-8 bytes", size, colferSizeMax));

				int shift = 0;
				for (int x = size; (x & ~((1 << 7) - 1)) != 0; x >>>= 7) shift++;
				if (shift != 0) System.arraycopy(buf, start, buf, start + shift, size);
				i = start + shift + size;

				start--;
				while ((size & ~((1 << 7) - 1)) != 0) {
					buf[start++] = (byte) (size | 0x80);
					size >>>= 7;
				}
				buf[start++] = (byte) size;
			}

			if (this.bitrate != 0) {
				int x = this.bitrate;
				if (x < 0) {
					x = -x;
					buf[i++] = (byte) (9 | 0x80);
				} else
					buf[i++] = (byte) 9;
				while ((x & ~((1 << 7) - 1)) != 0) {
					buf[i++] = (byte) (x | 0x80);
					x >>>= 7;
				}
				buf[i++] = (byte) x;
			}

			if (this.hasBitrate) {
				buf[i++] = (byte) 10;
			}

			if (this.flashPlay) {
				buf[i++] = (byte) 11;
			}

			if (this.javaPlay) {
				buf[i++] = (byte) 12;
			}

			buf[i++] = (byte) 0x7f;
			return i;
		} catch (IndexOutOfBoundsException e) {
			if (i - offset > colferSizeMax)
				throw new IllegalStateException(format("colfer: serial exceeds %d bytes", colferSizeMax));
			if (i >= buf.length)
				throw new BufferOverflowException();
			throw new RuntimeException("colfer: bug", e);
		}
	}

	/**
	 * Deserializes the object.
	 * @param buf the data source.
	 * @param offset the first byte index.
	 * @return the index of the first byte after the last byte read.
	 * @throws BufferUnderflowException when {@code buf} is incomplete. (EOF)
	 * @throws TypeConstraintException on an upper limit breach defined by either {@link #colferSizeMax} or {@link #colferListMax}.
	 * @throws DataBindingException when the data does not match this object's schema.
	 */
	public int unmarshal(byte[] buf, int offset)
	throws BufferUnderflowException, TypeConstraintException, DataBindingException {
		int i = offset;
		try {
			byte header = buf[i++];

			if (header == (byte) 0) {
				int n = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					n |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				if (n > colferSizeMax)
					throw new TypeConstraintException(format("colfer: field serializers/colfer/media.media.uri size %d exceeds %d UTF-8 bytes", n, colferSizeMax));
				this.uri = new String(buf, i, n, this._utf8);
				i += n;
				header = buf[i++];
			}

			if (header == (byte) 1) {
				int n = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					n |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				if (n > colferSizeMax)
					throw new TypeConstraintException(format("colfer: field serializers/colfer/media.media.title size %d exceeds %d UTF-8 bytes", n, colferSizeMax));
				this.title = new String(buf, i, n, this._utf8);
				i += n;
				header = buf[i++];
			}

			if (header == (byte) 2) {
				int x = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					x |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				this.width = x;
				header = buf[i++];
			} else if (header == (byte) (2 | 0x80)) {
				int x = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					x |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				this.width = -x;
				header = buf[i++];
			}

			if (header == (byte) 3) {
				int x = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					x |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				this.height = x;
				header = buf[i++];
			} else if (header == (byte) (3 | 0x80)) {
				int x = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					x |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				this.height = -x;
				header = buf[i++];
			}

			if (header == (byte) 4) {
				int n = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					n |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				if (n > colferSizeMax)
					throw new TypeConstraintException(format("colfer: field serializers/colfer/media.media.format size %d exceeds %d UTF-8 bytes", n, colferSizeMax));
				this.format = new String(buf, i, n, this._utf8);
				i += n;
				header = buf[i++];
			}

			if (header == (byte) 5) {
				long x = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					if (shift == 56 || b >= 0) {
						x |= (b & 0xffL) << shift;
						break;
					}
					x |= (b & 0x7fL) << shift;
				}
				this.duration = x;
				header = buf[i++];
			} else if (header == (byte) (5 | 0x80)) {
				long x = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					if (shift == 56 || b >= 0) {
						x |= (b & 0xffL) << shift;
						break;
					}
					x |= (b & 0x7fL) << shift;
				}
				this.duration = -x;
				header = buf[i++];
			}

			if (header == (byte) 6) {
				long x = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					if (shift == 56 || b >= 0) {
						x |= (b & 0xffL) << shift;
						break;
					}
					x |= (b & 0x7fL) << shift;
				}
				this.size = x;
				header = buf[i++];
			} else if (header == (byte) (6 | 0x80)) {
				long x = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					if (shift == 56 || b >= 0) {
						x |= (b & 0xffL) << shift;
						break;
					}
					x |= (b & 0x7fL) << shift;
				}
				this.size = -x;
				header = buf[i++];
			}

			if (header == (byte) 7) {
				int n = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					n |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				if (n > colferSizeMax)
					throw new TypeConstraintException(format("colfer: field serializers/colfer/media.media.persons size %d exceeds %d UTF-8 bytes", n, colferSizeMax));
				this.persons = new String(buf, i, n, this._utf8);
				i += n;
				header = buf[i++];
			}

			if (header == (byte) 8) {
				int n = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					n |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				if (n > colferSizeMax)
					throw new TypeConstraintException(format("colfer: field serializers/colfer/media.media.copyright size %d exceeds %d UTF-8 bytes", n, colferSizeMax));
				this.copyright = new String(buf, i, n, this._utf8);
				i += n;
				header = buf[i++];
			}

			if (header == (byte) 9) {
				int x = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					x |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				this.bitrate = x;
				header = buf[i++];
			} else if (header == (byte) (9 | 0x80)) {
				int x = 0;
				for (int shift = 0; true; shift += 7) {
					byte b = buf[i++];
					x |= (b & 0x7f) << shift;
					if (shift == 28 || b >= 0) break;
				}
				this.bitrate = -x;
				header = buf[i++];
			}

			if (header == (byte) 10) {
				this.hasBitrate = true;
				header = buf[i++];
			}

			if (header == (byte) 11) {
				this.flashPlay = true;
				header = buf[i++];
			}

			if (header == (byte) 12) {
				this.javaPlay = true;
				header = buf[i++];
			}

			if (header != (byte) 0x7f)
				throw new DataBindingException(format("colfer: unknown header at byte %d", i - 1), null);
		} catch (IndexOutOfBoundsException e) {
			if (i - offset > colferSizeMax)
				throw new TypeConstraintException(format("colfer: serial exceeds %d bytes", colferSizeMax));
			if (i >= buf.length)
				throw new BufferUnderflowException();
			throw new RuntimeException("colfer: bug", e);
		}

		return i;
	}

	public String getUri() {
		return this.uri;
	}

	public void setUri(String value) {
		this.uri = value;
	}

	public String getTitle() {
		return this.title;
	}

	public void setTitle(String value) {
		this.title = value;
	}

	public int getWidth() {
		return this.width;
	}

	public void setWidth(int value) {
		this.width = value;
	}

	public int getHeight() {
		return this.height;
	}

	public void setHeight(int value) {
		this.height = value;
	}

	public String getFormat() {
		return this.format;
	}

	public void setFormat(String value) {
		this.format = value;
	}

	public long getDuration() {
		return this.duration;
	}

	public void setDuration(long value) {
		this.duration = value;
	}

	public long getSize() {
		return this.size;
	}

	public void setSize(long value) {
		this.size = value;
	}

	public String getPersons() {
		return this.persons;
	}

	public void setPersons(String value) {
		this.persons = value;
	}

	public String getCopyright() {
		return this.copyright;
	}

	public void setCopyright(String value) {
		this.copyright = value;
	}

	public int getBitrate() {
		return this.bitrate;
	}

	public void setBitrate(int value) {
		this.bitrate = value;
	}

	public boolean getHasBitrate() {
		return this.hasBitrate;
	}

	public void setHasBitrate(boolean value) {
		this.hasBitrate = value;
	}

	public boolean getFlashPlay() {
		return this.flashPlay;
	}

	public void setFlashPlay(boolean value) {
		this.flashPlay = value;
	}

	public boolean getJavaPlay() {
		return this.javaPlay;
	}

	public void setJavaPlay(boolean value) {
		this.javaPlay = value;
	}

	@Override
	public final int hashCode() {
		return java.util.Objects.hash(0x7f, uri, title, width, height, format, duration, size, persons, copyright, bitrate, hasBitrate, flashPlay, javaPlay);
	}

	@Override
	public final boolean equals(Object o) {
		return o instanceof Media && equals((Media) o);
	}

	public final boolean equals(Media o) {
		return o != null
			&& java.util.Objects.equals(this.uri, o.uri)
			&& java.util.Objects.equals(this.title, o.title)
			&& this.width == o.width
			&& this.height == o.height
			&& java.util.Objects.equals(this.format, o.format)
			&& this.duration == o.duration
			&& this.size == o.size
			&& java.util.Objects.equals(this.persons, o.persons)
			&& java.util.Objects.equals(this.copyright, o.copyright)
			&& this.bitrate == o.bitrate
			&& this.hasBitrate == o.hasBitrate
			&& this.flashPlay == o.flashPlay
			&& this.javaPlay == o.javaPlay;
	}

}
